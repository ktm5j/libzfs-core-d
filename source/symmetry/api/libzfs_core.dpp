module symmetry.api.libzfs_core;

/+
	work towards Dlang wrapper for libzfs-core
+/

#define uint32_t uint

#include <stdint.h>
#include <libzfs_core.h>
#include <libnvpair.h>

import std.string:toStringz, fromStringz;
import std.exception;
import taggedalgebraic;
import std.conv:to;
import std.typecons:tuple;

alias toCString = toStringz;
alias fromCString = fromStringz;

struct SILdoc {string value; }

void rename(string from, string to)
{
	auto result = lzc_rename(from.toCString, to.toCString);
	enforce(result==0,"something went wrong");
}

// extern(C) void nvlist_free(nvlist_t*);
extern(C) int lzc_destroy_one(const(char) *fsname, nvlist_t *);
extern(C) int lzc_inherit(const(char)*fsname, const(char)*name, nvlist_t *);
extern(C) int lzc_set_props(const(char)*, nvlist_t *, nvlist_t *, nvlist_t *);
extern(C) int lzc_list(const(char)*, nvlist_t*);
   
enum DatasetType
{
	zfs = LZC_DATSET_TYPE_ZFS,
	zvol = LZC_DATSET_TYPE_ZVOL,
}


enum VdevType
{
	root,
	mirror,
	replacing,
	raidz,
	disk,
	file,
	missing,
	hole,
	spare,
	log,
	l2cache,
}

enum PoolStatus
{
	corruptCache,
	missingDevR,                         /* missing device with replicas */
	missingDevNr,                        /* missing device with no replicas */
	corruptLabelR,                       /* bad device label with replicas */
	corruptLabelNr,                      /* bad device label with no replicas */
	badGUIDSum,                          /* sum of device guids didn't match */
	corruptPool,                         /* pool metadata is corrupted */
	corruptData,                         /* data errors in user (meta)data */
	failingDev,                          /* device experiencing errors */
	versionNewer,                        /* newer on-disk version */
	hostidMismatch,                      /* last accessed by another system */
	hosidActive,                         /* currently active on another system */
	hostidRequired,                      /* multihost=on and hostid=0 */
	ioFailureWait,                       /* failed I/O, failmode 'wait' */
	ioFailureContinue,                   /* failed I/O, failmode 'continue' */
	ioFailureMap,                        /* ailed MMP, failmode not 'panic' */
	badLog,                              /* cannot read log chain(s) */
	errata,                              /* informational errata available */

	/*
	 * If the pool has unsupported features but can still be opened in
	 * read-only mode, its status is ZPOOL_STATUS_UNSUP_FEAT_WRITE. If the
	 * pool has unsupported features but cannot be opened at all, its
	 * status is ZPOOL_STATUS_UNSUP_FEAT_READ.
	 */
	unsupFeatRead,  /* unsupported features for read */
	unsupFeatWrite, /* unsupported features for write */

	/*
	 * These faults have no corresponding message ID.  At the time we are
	 * checking the status, the original reason for the FMA fault (I/O or
	 * checksum errors) has been lost.
	 */
	faultedDevR,  /* faulted device with replicas */
	faultedDevNr, /* faulted device with no replicas */

	/*
	 * The following are not faults per se, but still an error possibly
	 * requiring administrative attention.  There is no corresponding
	 * message ID.
	 */
	versionOlder, /* older legacy on-disk version */
	featDisabled, /* supported features are disabled */
	resilvering,  /* device being resilvered */
	offlineDev,   /* device online */
	removedDev,   /* removed device */

	/*
	 * Finally, the following indicates a healthy pool.
	 */
	ok,
}

// Possible ZFS pool states
enum PoolState
{
	active,            					/* In active use		*/
	exported,                           /* Explicitly exported		*/
	destroyed,                          /* Explicitly destroyed		*/
	spare,                              /* Reserved for hot spare use	*/
	l2cache,                            /* Level 2 ARC device		*/
	uninitialized,                      /* Internal spa_t state		*/
	unavail,                            /* Internal libzfs state	*/
	potentiallyActive                  /* Internal libzfs state	*/
}

// Pool properties. Enumerates available ZFS pool properties. Use it to access
// pool properties either to read or set soecific property.
enum PoolProperty
{
	cont,
	inval,
	name,
	size,
	capacity,
	altroot,
	health,
	guid,
	version_,
	bootfs,
	delegation,
	autoReplace,
	cacheFile,
	failureMode,
	listSnaps,
	autoExpand,
	dedupDitto,
	dedupRatio,
	free,
	allocated,
	readOnly,
	ashift,
	comment,
	expandSize,
	freeing,
	fragmentation,
	leaked,
	maxBlockSize,
	tName,
	maxNodeSize,
	multiHost,
	poolNumProps,
}


/*
 * Dataset properties are identified by these constants and must be added to
 * the end of this list to ensure that external consumers are not affected
 * by the change. If you make any changes to this list, be sure to update
 * the property table in module/zcommon/zfs_prop.c.
 */
enum DatasetProperty
{
	cont,
	bad,
	type,
	creation,
	used,
	available,
	referenced,
	compressRatio,
	mounted,
	origin,
	quota,
	reservation,
	volSize,
	volBlockSize,
	recordsize,
	mountpoint,
	sharenfs,
	checksum,
	compression,
	atime,
	devices,
	exec,
	setuid,
	readonly,
	zoned,
	snapdir,
	private_, /* not exposed to user, temporary */
	aclinherit,
	createTXG, /* not exposed to the user */
	name,      /* not exposed to the user */
	canmount,
	iscsioptions, /* not exposed to the user */
	xattr,
	numclones, /* not exposed to the user */
	copies,
	version_,
	utf8only,
	normalize,
	case_,
	vscan,
	nbmand,
	sharesmb,
	refquota,
	refreservation,
	guid,
	primarycache,
	secondarycache,
	usedsnap,
	usedds,
	usedchild,
	usedrefreserv,
	useraccounting, /* not exposed to the user */
	stmfShareinfo,  /* not exposed to the user */
	deferDestroy,
	userrefs,
	logbias,
	unique,   /* not exposed to the user */
	objsetid, /* not exposed to the user */
	dedup,
	mlslabel,
	sync,
	dnodeSize,
	refratio,
	written,
	clones,
	logicalused,
	logicalreferenced,
	inconsistent, /* not exposed to the user */
	volmode,
	filesystemLimit,
	snapshotLimit,
	filesystemCount,
	snapshotCount,
	snapdev,
	acltype,
	selinuxContext,
	selinuxFsContext,
	selinuxDefContext,
	selinuxRootContext,
	relatime,
	redundantMetadata,
	overlay,
	prevSnap,
	receiveResumeToken,
	encryption,
	keyLocation,
	keyFormat,
	pBKDF2Salt,
	pBKDF2Iters,
	encryptionRoot,
	keyGUID,
	keyStatus,
	remapTXG, /* not exposed to the user */
	datasetNumProps,
}


// ZFS errors
enum ZfsError
{
	success            = 0,            /* no error -- success */
	nomem               = 2000 , /* out of memory */
	badprop,                           /* invalid property value */
	propreadonly,                      /* cannot set readonly property */
	proptype,                          /* property does not apply to dataset type */
	propnoninherit,                    /* property is not inheritable */
	propspace,                         /* bad quota or reservation */
	badtype,                           /* dataset is not of appropriate type */
	busy,                              /* pool or dataset is busy */
	exists,                            /* pool or dataset already exists */
	noent,                             /* no such pool or dataset */
	badstream,                         /* bad backup stream */
	dsreadonly,                        /* dataset is readonly */
	voltoobig,                         /* volume is too large for 32-bit system */
	invalidname,                       /* invalid dataset name */
	badrestore,                        /* unable to restore to destination */
	badbackup,                         /* backup failed */
	badtarget,                         /* bad attach/detach/replace target */
	nodevice,                          /* no such device in pool */
	baddev,                            /* invalid device to add */
	noreplicas,                        /* no valid replicas */
	resilvering,                       /* currently resilvering */
	badversion,                        /* unsupported version */
	poolunavail,                       /* pool is currently unavailable */
	devoverflow,                       /* too many devices in one vdev */
	badpath,                           /* must be an absolute path */
	crosstarget,                       /* rename or clone across pool or dataset */
	zoned,                             /* used improperly in local zone */
	mountfailed,                       /* failed to mount dataset */
	umountfailed,                      /* failed to unmount dataset */
	unsharenfsfailed,                  /* unshare(1M) failed */
	sharenfsfailed,                    /* share(1M) failed */
	perm,                              /* permission denied */
	nospc,                             /* out of space */
	fault,                             /* bad address */
	io,                                /* I/O error */
	intr,                              /* signal received */
	isspare,                           /* device is a hot spare */
	invalconfig,                       /* invalid vdev configuration */
	recursive,                         /* recursive dependency */
	nohistory,                         /* no history object */
	poolprops,                         /* couldn't retrieve pool props */
	poolNotsup,                        /* ops not supported for this type of pool */
	poolInvalarg,                      /* invalid argument for this pool operation */
	nametoolong,                       /* dataset name is too long */
	openfailed,                        /* open of device failed */
	nocap,                             /* couldn't get capacity */
	labelfailed,                       /* write of label failed */
	badwho,                            /* invalid permission who */
	badperm,                           /* invalid permission */
	badpermset,                        /* invalid permission set name */
	nodelegation,                      /* delegated administration is disabled */
	unsharesmbfailed,                  /* failed to unshare over smb */
	sharesmbfailed,                    /* failed to share over smb */
	badcache,                          /* bad cache file */
	isl2CACHE,                         /* device is for the level 2 ARC */
	vdevnotsup,                        /* unsupported vdev type */
	notsup,                            /* ops not supported on this dataset */
	activeSpare,                       /* pool has active shared spare devices */
	unplayedLogs,                      /* log device has unplayed logs */
	reftagRele,                        /* snapshot release: tag not found */
	reftagHold,                        /* snapshot hold: tag already exists */
	tagtoolong,                        /* snapshot hold/rele: tag too long */
	pipefailed,                        /* pipe create failed */
	threadcreatefailed,                /* thread create failed */
	postsplitOnline,                   /* onlining a disk after splitting it */
	scrubbing,                         /* currently scrubbing */
	noScrub,                           /* no active scrub */
	diff,                              /* general failure of zfs diff */
	diffdata,                          /* bad zfs diff data */
	poolreadonly,                      /* pool is in read-only mode */
	unknown,
}

// vdev states are ordered from least to most healthy.
// A vdev that's CantOpen or below is considered unusable.
enum VdevState
{
	unknown,				// Uninitialized vdev
	closed,                    // Not currently open
	offline,                   // Not allowed to open
	removed,                   // Explicitly removed from system
	cantOpen,                  // Tried to open, but failed
	faulted,                   // External request to fault device
	degraded,                  // Replicated vdev with unhealthy kids
	healthy,                   // Presumed good
}

// vdev aux states.  When a vdev is in the CantOpen state, the aux field
// of the vdev stats structure uses these constants to distinguish why.
enum VdevAux
{
	none,
	openFailed,				    // ldi_open_*() or vn_open() failed
	corruptData,                 // bad label or disk contents
	noReplicas,                  // insufficient number of replicas
	badGUIDSum,                  // vdev guid sum doesn't match
	tooSmall,                    // vdev size is too small
	badLabel,                    // the label is OK but invalid
	versionNewer,                // on-disk version is too new
	versionOlder,                // on-disk version is too old
	unsupFeat,                   // unsupported features
	spared,                      // hot spare used in another pool
	errExceeded,                 // too many errors
	ioFailure,                   // experienced I/O failure
	badLog,                      // cannot read log chain(s)
	external,                    // external diagnosis
	splitPool,                   // vdev was split off into another pool
}



struct ZfsErrorResult
{
	int num;
	string text;
}


shared static this()
{
	enforce(libzfs_core_init() == 0, "Error initialising ZFS");
}

shared static ~this()
{
	libzfs_core_fini();
}	

version(None)
{
	auto toList(string[string] args)
	{
		nvlist_t** pNvList = nvlist_alloc(nvlistp,1,0); // UNIQUE NAME == 1
		enforce(pNvList !is null, "nvlist_alloca failed");
		scope(exit)
			nvlist_free(pNvList);
		return dictToNvList(args,pNvList);
	}

	auto asDict(nv_list* list)
	{
		string[string] ret;

		pair = nvlist_next_nvpair(list,null);
		while (pair !is null)
		{
			auto name = nvpair_name(pair).fromCString;
			auto id = type(pair);
		}
	}

	auto type(nvpair* pair)
	{
		auto id = nvpair_typie(pair);
	}
}

enum NvType
{
	unknown = DATA_TYPE_UNKNOWN,
	boolean = DATA_TYPE_BOOLEAN,
	byte_ = DATA_TYPE_BYTE,
	short_ = DATA_TYPE_INT16,
	ushort_ = DATA_TYPE_UINT16,
	int_ = DATA_TYPE_INT32,
	uint_ = DATA_TYPE_UINT32,
	long_ = DATA_TYPE_INT64,
	ulong_ = DATA_TYPE_UINT64,
	string_ = DATA_TYPE_STRING,
	byteArray = DATA_TYPE_BYTE_ARRAY,
	shortArray = DATA_TYPE_INT16_ARRAY,
	ushortArray = DATA_TYPE_UINT16_ARRAY,
	intArray = DATA_TYPE_INT32_ARRAY,
	uintArray = DATA_TYPE_UINT32_ARRAY,
	longArray = DATA_TYPE_INT64_ARRAY,
	ulongArray = DATA_TYPE_UINT64_ARRAY,
	stringArray = DATA_TYPE_STRING_ARRAY,
	hrTime = DATA_TYPE_HRTIME,
	nvList = DATA_TYPE_NVLIST,
	nvListArray = DATA_TYPE_NVLIST_ARRAY,
	booleanValue = DATA_TYPE_BOOLEAN_VALUE,
	int8 = DATA_TYPE_INT8,
	uint8 = DATA_TYPE_UINT8,
	booleanArray = DATA_TYPE_BOOLEAN_ARRAY,
	int8Array = DATA_TYPE_INT8_ARRAY,
	uint8Array =  DATA_TYPE_UINT8_ARRAY,
	double_ = DATA_TYPE_DOUBLE
}

union ZfsValueUnion
{
	bool boolean;
	byte byte_;
	char int8Value;
	ubyte ubyteValue;
	short short_;
	ushort ushort_;
	int int_;
	uint uint_;
	long long_;
	ulong ulong_;
	string string_;
	bool[] booleanArray;
	char[] charArray;
	ubyte[] ubyteArray;
	short[] shortArray;
	ushort[] ushortArray;
	int[] intArray;
	uint[] uintArray;
	long[] longArray;
	ulong[] ulongArray;
	string[] stringArray;
	//hrtime hrTime;
	//ZfsValue value;
	//ZfsValue[] valueArray;
	//ZfsValue[string] valueDict;
	double double_;
	ZfsValueUnion[] valueArray;
	ZfsValueUnion[string] valueDict;
}

alias ZfsValue = TaggedAlgebraic!ZfsValueUnion;

/+
nvlist_t* asList(ZfsValue[string] values)
{
	foreach(entry;values.byKeyValue)
	{
		final switch(entry.value.kind)
		{
			case ZfsValue.Kind.valueDict:
				nvlist_add_nvlist(list,entry.key.toCString,entry.value.asCValue);
				break;
	
			case ZfsValue.Kind.valueArray:
				nvlist_add_array(list,entry.key.toCString,entry.value.asCValue);
				break;

			case ZfsValue.
+/

@SILdoc(`Create a ZFS filesystem or a ZFS volume (zvol)
Params:
	string name					-	name of the dataset to be created
	DataSetType datasetType		-	dataset type (either zfs for a filesystem or zvol for a volume
	string[string] properties	-	a dictionary od ZFS dataset property name-value pairs
	ubyte[] encryptionKey		-	dataset encryption key data

Errors:
	FilesystemExists			-	if a dataset with the given name already exists
	ParentNotFound				-	if a parent dataset of the requested dataset does not exist
	PropertyInvalid				-	if one or more of specified properties does not exist or has an invalid type or value
	NameInvalid					-	if the name is not a valid dataset name
	NameTooLong					-	if the name is too long
	WrongParent					-	if the parent dataset of the requested dataset is not a filesystem eg zvol
`)
void create(string name, DatasetType dataSetType, string[string] properties = (string[string]).init, ubyte[] encryptionKey =[])
{
	import std.format:format;
	auto props = getProperties(properties);
	scope(exit)
		nvlistFree(props);
	auto result = lzc_create(name.toCString, cast(lzc_dataset_type) dataSetType, props,encryptionKey.ptr,encryptionKey.length.to!uint_t);
	enforce(result==0, format!"zfs create: %s"(result));
}

@SILdoc(`Clone a ZFS filesystem or a ZFS volume ("zvol") from a given snapshot.
Params:
	string name: a name of the dataset to be created.
	string origin: a name of the origin snapshot.
	string[string] properties: ZFS dataset property name-value pairs

Errors:
	FilesystemExists: if a dataset with the given name already exists.
	DatasetNotFound: if either a parent dataset of the requested dataset or the origin snapshot does not exist.
	PropertyInvalid: if one or more of the specified properties is invalid or has an invalid type or value.
	FilesystemNameInvalid: if the name is not a valid dataset name.
	SnapshotNameInvalid: if the origin is not a valid snapshot name.
	NameTooLong: if the name or the origin name is too long.
	PoolsDiffer: if the clone and the origin have different pool names.
Note:
	Because of a deficiency of the underlying C interface DatasetNotFound can mean that either a parent filesystem of the target or the origin snapshot does not exist.  It is currently impossible to distinguish between the cases.
	lzc_hold can be used to check that the snapshot exists and ensure that it is not destroyed before cloning.
`)
void clone(string name, string origin, string[string] properties = (string[string]).init)
{
	auto props = getProperties(properties);
	scope(exit)
		nvlistFree(props);
	auto result = lzc_clone(name.toCString,origin.toCString,props);
	enforce(result==0,"something went wrong");
}

@SILdoc(`Promotes the ZFS dataset.
Params:
	string name: the name of the dataset to promote.

Errors:
	NameInvalid: if the dataset name is invalid.
    NameTooLong: if the dataset name is too longor  if the dataset's origin has a snapshot that, if transferred to the dataset, would get a too long name.
    NotClone: if the dataset is not a clone.
    FilesystemNotFound: if the dataset does not exist.
    SnapshotExists: if the dataset already has a snapshot with the same name as one of the origin's snapshots.
`)
string promote(string name)
{
	char[16384] buf;
	auto result = lzc_promote(name.toCString,buf.ptr, buf.length);
	enforce(result==0,"something went wrong");
	return buf.ptr.fromCString.idup;
}

@SILdoc(`Rename the ZFS dataset.
Params:
	string from: the current name of the dataset to rename.
	string to: the new name of the dataset.

Errors:
    NameInvalid: if either the source or target name is invalid.
    NameTooLong: if either the source or target name is too long.
    NameTooLong: if a snapshot of the source would get a too long name after renaming.
    FilesystemNotFound: if the source does not exist.
    FilesystemNotFound: if the target's parent does not exist.
    FilesystemExists: if the target already exists.
    PoolsDiffer: if the source and target belong to different pools.
`)
void rename(string from, string to)
{
	auto result = lzc_rename(from.toCString, to.toCString);
	enforce(result==0,"something went wrong");
}

@SILdoc(`Remaps the ZFS dataset.
Params:
	string name: the name of the dataset to remap.

Errors:
	NameInvalid: if the dataset name is invalid.
    NameTooLong: if the dataset name is too long.
    DatasetNotFound: if the dataset does not exist.
    FeatureNotSupported: if the pool containing the dataset does not have the *obsolete_counts* feature enabled.
`)
void remap(string filesystem)
{
	auto result = lzc_remap(filesystem.toCString);
	enforce(result==0,"something went wrong");
}

@SILdoc(`Calculate a size of data referenced by snapshots in the inclusive range between the firstsnap and the lastsnap and not shared with any other datasets.

Params:
    string firstSnap: the name of the first snapshot in the range.
    string lastSnap: the name of the last snapshot in the range.

Returns:
	ulong: the calculated stream size, in bytes.

Errors:
    SnapshotNotFound: if either of the snapshots does not exist.
    NameInvalid: if the name of either snapshot is invalid.
    NameTooLong: if the name of either snapshot is too long.
    SnapshotMismatch: if fromsnap is not an ancestor snapshot of snapname
    PoolsDiffer: if the snapshots belong to different pools.

snapRangeSpace calculates total size of blocks that exist because they are referenced only by one or more snapshots in the given range but no other dataset.  In other words, this is the set of blocks that were born after the snap before firstsnap, and died before the snap after the last snap.  Yet another interpretation is that the result of snapRangeSpace is the size of the space that would be freed if the snapshots in the range are destroyed.  If the same snapshot is given as both the firstSnap and the lastSnap then snapRangeSpace calculates space used by the snapshot.
`)
ulong snapRangeSpace(string firstSnap, string lastSnap)
{
	ulong ret;
	auto result = lzc_snaprange_space(firstSnap.toCString, lastSnap.toCString,&ret);
	enforce(result>=0, "zfs error");
	return ret;
}

@SILdoc(`
Forces all in-core dirty data to be written to the primary pool storage and not the ZIL.
Params:
    string poolname: the name of the pool.
    bool force: whether to force uberblock update even if there is no dirty data.
`)
auto poolSync(string poolName, bool force)
{
	import std.format: format;
	nvlist_t* outnvl;
	auto innvl = nvlistAlloc(NV_UNIQUE_NAME, 0);
	if (force)
		nvlistAddBoolean(innvl,"force");
	auto result = lzc_sync(poolName.toCString,innvl,&outnvl);
	enforce(result ==0, format!"error during pool sync: %s"(result));
}

@SILdoc(`Create user holds on snapshots.  If there is a hold on a snapshot, the snapshot can not be destroyed.  (However, it can be marked for deletion by destroySnaps{defer:true} ).
Parameters:
    string[string] holds: the dictionary of names of the snapshots to hold mapped to the hold names.
    int fileDescriptor: result of opening file

Returns:
    string[]	: list of snapshots that do not exist

Errors:
    HoldFailure: if a hold was impossible on one or more of the snapshots.
    BadHoldCleanupFD: if fd is not a valid file descriptor associated with /dev/zfs

The snapshots must all be in the same pool.

If cleanupFd is set, then when the Fd is closed (including on process termination), the holds will be released.  If the system is shut down uncleanly, the holds will be released when the pool is next opened or imported.  Holds for snapshots which dont exist will be skipped and have an entry added to the return value, but will not cause an overall failure.  No exceptions is raised if all holds, for snapshots that existed, were succesfully created.
`)
void holdSnapshot(string[string] holdsMap, int cleanupFd = -1)
{
	import std.format:format;
	nvlist_t* errlist;
	auto holds = getProperties(holdsMap);
	auto result = lzc_hold(holds, cleanupFd, &errlist);
	enforce(result ==0, format!"error during holdsnaps: %s / %s"(result,processErrorList(errlist)));
}

@SILdoc(`Release user holds on snapshots.
If the snapshot has been marked for deferred destroy (by destroySnapshots({defer:true}), it does not have any clones, and all the user holds are removed, then the snapshot will be destroyed.  The snapshots must all be in the same pool.
Params:
    string[string] holdsMap: a map where keys are snapshot names and values are lists of hold tags to remove.
Returns:
	an array of any snapshots that do not exist and of any tags that do not exist for existing snapshots.  Such tags are qualified with a corresponding snapshot name using the following format :file:{pool}/{fs}@{snap}#{tag}
Errors:
	HoldReleaseFailure: if one or more existing holds could not be released.
Holds which failed to release because they didnt exist will have an entry added to errlist, but will not cause an overall failure.  This call is success if holds was empty or all holds that existed, were successfully removed.  Otherwise an exception will be raised.
`)
void releaseSnapshot(string[string] holdsMap)
{
	import std.format:format;
	nvlist_t* errlist;
	auto holds = getProperties(holdsMap);
	auto result = lzc_release(holds, &errlist);
	enforce(result ==0, format!"error during unholdsnaps: %s / %s"(result,processErrorList(errlist)));
}

@SILdoc(`Retrieve list of *user holds* on the specified snapshot.
Params:
	string snapName: the name of the snapshot

Returns:
	ulong[string] holds on the snapshots along with their creation times in seconds since the epoch
`)
ulong[string] getHeldSnapshots(string snapName)
{
	import std.format:format;
	nvlist_t* holdsp;
	auto result = lzc_get_holds(snapName.toCString, &holdsp);
	enforce(result ==0, format!"error during getHeldSnapshots: %s"(result));
	return holdsp.processNvlist!(ulong[string]);
}

enum SendFlag
{
	largeBlock = LZC_SEND_FLAG_LARGE_BLOCK,
	embedData = LZC_SEND_FLAG_EMBED_DATA,
	compress = LZC_SEND_FLAG_COMPRESS,
	raw = LZC_SEND_FLAG_RAW
}

@SILdoc(`Generate a zfs send stream for the specified snapshot and write it to the specified file descriptor.
Params:
    string snapname: the name of the snapshot to send.
    string fromsnap: if not empty the name of the starting snapshot for the incremental stream.
    int fileDescriptor: the file descriptor to write the send stream to.
    SendFlag[] flags: the flags that control what enhanced features can be used in the stream.
Errors:
	SnapshotNotFound: if either the starting snapshot is set and does not exist, or if the ending snapshot does not exist.
    NameInvalid: if the name of either snapshot is invalid.
    NameTooLong: if the name of either snapshot is too long.
    SnapshotMismatch: if fromsnap is not an ancestor snapshot of snapname
    PoolsDiffer: if the snapshots belong to different pools.
    IOError: if an input / output error occurs while writing to fd
    UnknownStreamFeature: if the flags contain an unknown flag name.

If fromsnap is empty, a full (non-incremental) stream will be sent.
If fromsnap is not empty, it must be the full name of a snapshot or bookmark to send an incremental from, e.g.  :file:{pool}/{fs}@{earlier_snap} or :file:{pool}/{fs}#{earlier_bmark}.  The specified snapshot or bookmark must represent an earlier point in the history of snapname.  It can be an earlier snapshot in the same filesystem or zvol as snapname, or it can be the origin of snapnames filesystem, or an earlier snapshot in the origin, etc.  fromsnap must be strictly an earlier snapshot, specifying the same snapshot as both fromsnap and snapname is an error.

If flags contains *"large_blocks"*, the stream is permitted to contain DRR_WRITE records with drr_length > 128K, and DRR_OBJECT records with drr_blksz > 128K.  If flags contains *"embedded_data"*, the stream is permitted to contain DRR_WRITE_EMBEDDED records with drr_etype == BP_EMBEDDED_TYPE_DATA, which the receiving system must support (as indicated by support for the *embedded_data* feature).  If flags contains *"compress"*, the stream is generated by using compressed WRITE records for blocks which are compressed on disk and in memory.  If the *lz4_compress* feature is active on the sending system, then the receiving system must have that feature enabled as well.  If flags contains *"raw"*, the stream is generated, for encrypted datasets, by sending data exactly as it exists on disk.  This allows backups to be taken even if encryption keys are not currently loaded.

note:
	lzc_send can actually accept a filesystem name as the snapname.  In that case lzc_send acts as if a temporary snapshot was created after the start of the call and before the stream starts being produced.
	lzc_send does not return until all of the stream is written to fd.
	lzc_send does *not* close fd upon returning.
`)
void sendSnapshot(string snapshotName, string fromSnapshot, int fileDescriptor, SendFlag[] flags)
{
	import std.algorithm:fold;
	auto lzcFlags = flags.fold!((a,b) => a| b)(cast(SendFlag)0).to!lzc_send_flags;
	auto result = lzc_send(snapshotName.toCString, fromSnapshot.toCString,fileDescriptor,lzcFlags);
	enforce(result == 0, "zfs error");
}

@SILdoc(`Resume a previously interrupted send operation generating a zfs send stream for the specified snapshot and writing it to the specified file descriptor.
Params:
    string snapname: the name of the snapshot to send.
    string fromsnap: if set the name of the starting snapshot for the incremental stream.
    int fd: the file descriptor to write the send stream to.
    SendFlag[] flags: the flags that control what enhanced features can be used in the stream.
    ulong resumeobj: the object number where this send stream should resume from.
    ulong resumeoff: the offset where this send stream should resume from.

Errors:
    SnapshotNotFound: if either the starting snapshot is set and does not exist, or if the ending snapshot does not exist.
    NameInvalid: if the name of either snapshot is invalid.
    NameTooLong: if the name of either snapshot is too long.
    SnapshotMismatch: if fromsnap is not an ancestor snapshot of snapname
    PoolsDiffer: if the snapshots belong to different pools.
    IOError: if an input / output error occurs while writing to fd
    UnknownStreamFeature: if the flags contain an unknown flag name.

note:
	See sendSnapshot for more information
`)
auto sendResume(string snapshotName, string fromSnapshot, int fileDescriptor, SendFlag[] flags, ulong resumeObj, ulong resumeOff)
{
	import std.algorithm:fold;
	auto lzcFlags = flags.fold!((a,b) => a| b)(cast(SendFlag)0).to!lzc_send_flags;
	auto result = lzc_send_resume(snapshotName.toCString, fromSnapshot.toCString, fileDescriptor, lzcFlags, resumeObj, resumeOff);
	enforce(result == 0, "zfs error");
}

@SILdoc(`
"from" can be NULL, a snapshot, or a bookmark.

If from is NULL, a full (non-incremental) stream will be estimated.  This
is calculated very efficiently.

If from is a snapshot, lzc_send_space uses the deadlists attached to
each snapshot to efficiently estimate the stream size.

If from is a bookmark, the indirect blocks in the destination snapshot
are traversed, looking for blocks with a birth time since the creation TXG of
the snapshot this bookmark was created from.  This will result in
significantly more I/O and be less efficient than a send space estimation on
an equivalent snapshot.
`)
auto sendSpace(string snapshotName, string from, SendFlag[] flags)
{
	import std.algorithm:fold;
	auto lzcFlags = flags.fold!((a,b) => a| b)(cast(SendFlag)0).to!lzc_send_flags;
	ulong retSpace;
	auto result = lzc_send_space(snapshotName.toCString, from.toCString, lzcFlags,&retSpace);
	enforce(result == 0, "zfs error");
	return retSpace;
}


/+
*
 * Linux adds ZFS_IOC_RECV_NEW for resumable and raw streams and preserves the
 * legacy ZFS_IOC_RECV user/kernel interface.  The new interface supports all
 * stream options but is currently only used for resumable streams.  This way
 * updated user space utilities will interoperate with older kernel modules.
 *
 * Non-Linux OpenZFS platforms have opted to modify the legacy interface.
 */
int recv_impl(const char *snapname, nvlist_t *recvdprops, nvlist_t *localprops, uint8_t *wkeydata, uint_t wkeylen, const char *origin, boolean_t force, boolean_t resumable, boolean_t raw, int input_fd, const dmu_replay_record *begin_record, int cleanup_fd, uint64_t *read_bytes, uint64_t *errflags, uint64_t *action_handle, nvlist_t **errors)

+/

@SILdoc(`zfs receive:
The simplest receive case: receive from the specified fd, creating the specified snapshot.  Apply the specified properties as "received" properties (which can be overridden by locally-set properties).  If the stream is a clone, its origin snapshot must be specified by origin.  The 'force' flag will cause the target filesystem to be rolled back or destroyed if necessary to receive.

Return 0 on success or an errno on failure.

Note: this interface does not work on dedupd streams (those with DMU_BACKUP_FEATURE_DEDUP).

resumable: Like lzc_receive, but if the receive fails due to premature stream termination, the intermediate state will be preserved on disk.  In this case, ECKSUM will be returned.  The receive may subsequently be resumed with a resuming send stream generated by lzc_send_resume().
`)
void zfsReceive(string snapName, string origin, bool force, bool raw, int fileDescriptor, string[string] properties = (string[string]).init, bool resumable = false)
{
	import std.format:format;
	auto props = getProperties(properties);
	scope(exit)
		nvlistFree(props);
	auto result = resumable ? lzc_receive(snapName.toCString, props,origin.toCString, force? 1:0, raw?1:0, fileDescriptor) :
			lzc_receive_resumable(snapName.toCString, props,origin.toCString, force?1:0, raw? 1:0, fileDescriptor);
	enforce(result == 0, format!"zfs error: %s"(result));
}

@SILdoc(`zfsReceiveWithHeader
Like lzc_receive, but allows the caller to read the begin record and then to pass it in.  That could be useful if the caller wants to derive, for example, the snapname or the origin parameters based on the information contained in the begin record.
The begin record must be in its original form as read from the stream, in other words, it should not be byteswapped.

The 'resumable' parameter allows to obtain the same behavior as with lzc_receive_resumable.
`)
void zfsReceiveWithHeader(string snapName, string[string] properties, string origin, bool force, bool resumable, bool raw, int fileDescriptor, dmu_replay_record* beginRecord)
{
	auto props = getProperties(properties);
	scope(exit)
		nvlistFree(props);
	auto result = lzc_receive_with_header(snapName.toCString, props, origin.toCString, force ? 1 :0, resumable ? 1 : 0, raw ? 1 :0, fileDescriptor, beginRecord);
	enforce(result == 0);
}

@SILdoc(`zfsReceiveOne
Like lzc_receive, but allows the caller to pass all supported arguments and retrieve all values returned.  The only additional input parameter is 'cleanup_fd' which is used to set a cleanup-on-exit file descriptor.

The following parameters all provide return values.  Several may be set in the failure case and will contain additional information.
 
The 'read_bytes' value will be set to the total number of bytes read.
The 'errflags' value will contain zprop_errflags_t flags which are used to describe any failures.
The 'action_handle' is used to pass the handle for this guid/ds mapping. It should be set to zero on first call and will contain an updated handle on success, it should be passed in subsequent calls.
The 'errors' nvlist contains an entry for each unapplied received property.  Callers are responsible for freeing this nvlist.
`)
auto zfsReceiveOne(string snapName, string[string] properties, string origin, bool force, bool resumable, bool raw, int fileDescriptor, dmu_replay_record* beginRecord, int cleanupFileDescriptor, ulong actionHandle = 0UL)
{
	ulong readBytes;
	ulong errorFlags;
	nvlist_t* errorList;
	auto props = getProperties(properties);
	scope(exit)
		nvlistFree(props);
	auto result = lzc_receive_one(snapName.toCString, props, origin.toCString, force ? 1 : 0, resumable ? 1 :0, raw ? 1 : 0, fileDescriptor, beginRecord, cleanupFileDescriptor, &readBytes, &errorFlags, &actionHandle,&errorList);
	enforce(result == 0);
	return tuple(readBytes,actionHandle,errorFlags,errorList.processErrorList);
}


@SILdoc(`Like lzc_receive_one, but allows the caller to pass an additional 'cmdprops' argument.

The 'cmdprops' nvlist contains both override ('zfs receive -o') and
exclude ('zfs receive -x') properties. Callers are responsible for freeing
this nvlist
`)
auto zfsReceiveWithCommandProperties(string snapName, string[string] properties, string[string] commandProperties, ubyte[] keyData, string origin, bool force, bool resumable, bool raw, int inputFileDescriptor, dmu_replay_record* beginRecord, int cleanupFileDescriptor,ulong actionHandle = 0UL)
{
	import std.format:format;
	ulong readBytes;
	ulong errorFlags;
	nvlist_t* errors;
	auto props = getProperties(properties);
	scope(exit)
		nvlistFree(props);
	auto cmdProps = getProperties(commandProperties);
	scope(exit)
		nvlistFree(cmdProps);
	auto result = lzc_receive_with_cmdprops(snapName.toCString, props, cmdProps, keyData.ptr, keyData.length.to!uint, origin.toCString, force ? 1 :0, resumable ? 1 :0, raw ? 1 : 0, inputFileDescriptor, beginRecord, cleanupFileDescriptor, &readBytes, &errorFlags, &actionHandle, &errors);
	enforce(result == 0, format!"zfs error %s"(result));
	return tuple(readBytes,actionHandle,errorFlags,errors.processErrorList);
}


@SILdoc(`Roll back this filesystem or volume to its most recent snapshot
returns the name of the most recent snapshot.  Note that the latest snapshot may change if a new one is concurrently created or the current one is destroyed.  lzc_rollback_to can be used to roll back to a specific latest snapshot.`)
string rollback(string fsname)
{
	import std.format:format;
	char[16384] buf;
	auto result = lzc_rollback(fsname.toCString, buf.ptr, buf.length.to!int);
	enforce(result ==0, format!"libzfs_core error %s rolling back on %s"(result,fsname));
	return buf.ptr.fromCString.idup;
}

@SILdoc(`Roll back this filesystem or volume to the specified snapshot, if possible`)
void rollbackTo(string fsName, string snapName)
{
	import std.format:format;
	auto result = lzc_rollback_to(fsName.toCString, snapName.toCString);
	enforce(result == 0, format!"zfs error: %s"(result));
}

@SILdoc(`Creates bookmarks.

The bookmarks nvlist maps from name of the bookmark (e.g. "pool/fs#bmark") to
the name of the snapshot (e.g. "pool/fs@snap").  All the bookmarks and
snapshots must be in the same pool.

The returned results nvlist will have an entry for each bookmark that failed.
The value will be the (int32) error code.

The return value will be 0 if all bookmarks were created, otherwise it will
be the errno of a (undetermined) bookmarks that failed.
`)
auto createBookmarks(string[string] bookmarks)
{
	import std.format:format;
	nvlist_t* errlist;
	auto list = getProperties(bookmarks);
	scope(exit)
		nvlistFree(list);
	auto result = lzc_bookmark(list, &errlist);
	enforce(result == 0, format!" zfs error: %s"(result));
}


@SILdoc(`
Retrieve bookmarks.

Retrieve the list of bookmarks for the given file system. The props
parameter is an nvlist of property names (with no values) that will be
returned for each bookmark.

The following are valid properties on bookmarks, all of which are numbers
(represented as uint64 in the nvlist)

"guid" - globally unique identifier of the snapshot it refers to
"createtxg" - txg when the snapshot it refers to was created
"creation" - timestamp when the snapshot it refers to was created

The format of the returned nvlist as follows:
 <short name of bookmark> -> {
    <name of property> -> {
         "value" -> uint64
    }
  }
`)
ulong[string][string] getBookmarks(string fsName, string[] properties)
{
	nvlist_t* bmarks;
	auto props = getList(properties);
	scope(exit)
		nvlistFree(props);
	auto result = lzc_get_bookmarks(fsName.toStringz, props,&bmarks);
	enforce(result == 0, "ZFS error");
	return bmarks.processNvlist!(ulong[string][string]);
}

@SILdoc(`Destroys bookmarks

The keys in the bmarks nvlist are the bookmarks to be destroyed.
They must all be in the same pool.  Bookmarks are specified as
<fs>#<bmark>.

Bookmarks that do not exist will be silently ignored.

The return value will be 0 if all bookmarks that existed were destroyed.

Otherwise the return value will be the errno of a (undetermined) bookmark
that failed, no bookmarks will be destroyed, and the errlist will have an
entry for each bookmarks that failed.  The value in the errlist will be
the (int32) error code.
`)
auto destroyBookmarks(string[] bookmarks)
{
	nvlist_t* errlist;
	auto list = getList(bookmarks);
	scope(exit)
		nvlistFree(list);
	auto result = lzc_destroy_bookmarks(list,&errlist);
	enforce(result == 0, "zfs error");
	return 0;
}

@SILdoc(`Executes a channel program

If this function returns 0 the channel program was successfully loaded and
ran without failing. Note that individual commands the channel program ran
may have failed and the channel program is responsible for reporting such
errors through outnvl if they are important.

This method may also return:

 EINVAL   The program contains syntax errors, or an invalid memory or time
          limit was given. No part of the channel program was executed.
          If caused by syntax errors, 'outnvl' contains information about the
          errors.

 ECHRNG   The program was executed, but encountered a runtime error, such as
          calling a function with incorrect arguments, invoking the error()
          function directly, failing an assert() command, etc. Some portion
          of the channel program may have executed and committed changes.
          Information about the failure can be found in 'outnvl'.

 ENOMEM   The program fully executed, but the output buffer was not large
          enough to store the returned value. No output is returned through
          'outnvl'.

 ENOSPC   The program was terminated because it exceeded its memory usage
          limit. Some portion of the channel program may have executed and
          committed changes to disk. No output is returned through 'outnvl'.

 ETIME    The program was terminated because it exceeded its Lua instruction
          limit. Some portion of the channel program may have executed and
          committed changes to disk. No output is returned through 'outnvl'.
`)
void executeChannelProgram(string pool, string program, string[string] parameters, ulong instrLimit = ZCP_DEFAULT_INSTRLIMIT, ulong memLimit=ZCP_DEFAULT_MEMLIMIT)
{
	import std.format: format;
	// should pass args
	auto params = getProperties(parameters);
	scope(exit)
		nvlistFree(params);
	nvlist_t* outnvl;
	auto result = lzc_channel_program(pool.toCString, program.toCString, instrLimit, memLimit, params,&outnvl);
	enforce(result == 0, format!"zfs error: %s"(result));
}

@SILdoc(`Creates a checkpoint for the specified pool.

If this function returns 0 the pool was successfully checkpointed.

This method may also return:

 ZFS_ERR_CHECKPOINT_EXISTS
	The pool already has a checkpoint. A pools can only have one
    checkpoint at most, at any given time.

 ZFS_ERR_DISCARDING_CHECKPOINT
 	ZFS is in the middle of discarding a checkpoint for this pool.
 	The pool can be checkpointed again once the discard is done.

 ZFS_DEVRM_IN_PROGRESS
 	A vdev is currently being removed. The pool cannot be
 	checkpointed until the device removal is done.

 ZFS_VDEV_TOO_BIG
 	One or more top-level vdevs exceed the maximum vdev size
 	supported for this feature.
`)
void createCheckpoint(string pool)
{
	import std.format:format;
	auto result = lzc_pool_checkpoint(pool.toCString);
	enforce(result == 0, format!"zfs error: %s"(result));
}

@SILdoc(`Discard the checkpoint from the specified pool`)
void discardCheckpoint(string pool)
{
	auto result = lzc_pool_checkpoint_discard(pool.toCString);
	enforce(result != ZFS_ERR_NO_CHECKPOINT, "The pool does not have a checkpoint.");
	enforce(result != ZFS_ERR_DISCARDING_CHECKPOINT, "ZFS is already in the middle of discarding the checkpoint.");
	enforce(result != ZFS_ERR_CHECKPOINT_EXISTS, "ZFS checkpoint already exists");
	//enforce(result != ZFS_DEVRM_IN_PROGRESS,"A vdev is currently being removed");
	//enforce(result != ZFS_VDEV_TOO_BIG,"One or more top-level vdevs exceed max vdev size supported for this feature");
}

@SILdoc(`
Executes a read-only channel program.

A read-only channel program works programmatically the same way as a
normal channel program executed with lzc_channel_program(). The only
difference is it runs exclusively in open-context and therefore can
return faster. The downside to that, is that the program cannot change
on-disk state by calling functions from the zfs.sync submodule.

The return values of this function (and their meaning) are exactly the
same as the ones described in lzc_channel_program().
`)
void executeChannelProgramNoSync(string pool, string program, string[string] parameters, ulong instrLimit = ZCP_DEFAULT_INSTRLIMIT, ulong memLimit=ZCP_DEFAULT_MEMLIMIT)
{
	import std.format: format;
	auto params = getProperties(parameters);
	scope(exit)
		nvlistFree(params);
	nvlist_t* outnvl;
	auto result = lzc_channel_program_nosync(pool.toCString, program.toCString, instrLimit, memLimit, params, &outnvl);
	enforce(result == 0, format!"zfs error: %s"(result));
}


@SILdoc(`Load or verify encryption key on the specified dataset.
Params:
	string fsName: the name of the dataset
	bool noOp: if true the encryption key will only be verified, not loaded
	string encryptionKey: dataset encryption key data

Errors:
    FilesystemNotFound: if the dataset does not exist.
    EncryptionKeyAlreadyLoaded: if the encryption key is already loaded.
    EncryptionKeyInvalid: if the encryption key provided is incorrect.
`)
auto loadKey(string fsName, bool noOp, string encryptionKey)
{
	import std.format:format;
	auto result = lzc_load_key(fsName.toCString, noOp ? 1 : 0, cast(ubyte*)encryptionKey.ptr, encryptionKey.length.to!uint);
	enforce(result ==0, format!"loadkey failed with %s"(result));
}

@SILdoc(`Unload encryption key from the specified dataset.
Params:
	string fsName: the name of the dataset.

Errors:
	FilesystemNotFound: if the dataset does not exist.
    DatasetBusy: if the encryption key is still being used. This usually occurs when the dataset is mounted.
    EncryptionKeyNotLoaded: if the encryption key is not currently loaded.
`)
void unloadKey(string fsName)
{
	import std.format:format;
	auto result = lzc_unload_key(fsName.toCString);
	enforce(result ==0, format!"unLoadkey failed with %s"(result));
}

//FIXME -- check these
enum DCP_CMD_NEW_KEY = 0;
enum DCP_CMD_INHERIT = 1;
enum DCP_CMD_FORCE_NEW_KEY = 2;
enum DCP_CMD_FORCE_INHERIT = 3;
enum EncryptionCommand
{
	newKey = DCP_CMD_NEW_KEY,
	inherit = DCP_CMD_INHERIT,
	forceNewKey = DCP_CMD_FORCE_NEW_KEY,
	forceInherit = DCP_CMD_FORCE_INHERIT,
}

@SILdoc(`Change encryption key on the specified dataset.
Params:
	string fsName: the name of the dataset.
    EncryptionCommand cryptCommand: the encryption "command" to be executed, currently supported values are "new_key", "inherit", "force_new_key" and "force_inherit"
    string[string] properties: a dictionary of encryption-related property name-value pairs; only "keyformat", "keylocation" and "pbkdf2iters" are supported (empty by default).
    string[] encryptionKey: dataset encryption key data (empty by default).

Errors:
    PropertyInvalid: if props contains invalid values.
    FilesystemNotFound: if the dataset does not exist.
    UnknownCryptCommand: if cryptCommand is invalid.
    EncryptionKeyNotLoaded: if the encryption key is not currently loaded and therefore cannot be changed.
`)
auto changeKey(string fsName, EncryptionCommand cryptCommand,  string encryptionKey, string[string] properties = (string[string]).init)
{
	import std.format:format;
	auto props = getProperties(properties);
	scope(exit)
		nvlistFree(props);
	auto result = lzc_change_key(fsName.toCString, cryptCommand.to!ulong, props,cast(ubyte*)encryptionKey.ptr, encryptionKey.length.to!uint);
	enforce(result ==0, format!"changeKey failed with %s"(result));
}

@SILdoc(`Reopen a pool
Params:
    string pool: the name of the pool.
    bool restartScrub: whether to restart an in-progress scrub operation.
Errors:
    PoolNotFound: if the pool does not exist
`)
void reopen(string pool, bool restartScrub = false)
{
	import std.format:format;
	auto result = lzc_reopen(pool.toCString, restartScrub ? 1 : 0);
	enforce(result ==0, format!"reopen failed with %s"(result));
}



// clone
    // promote
    // destroy_snaps
    // bookmark
    // get_bookmarks
    // destroy_bookmarks
    // snaprange_space
    // hold
    // release
    // get_holds
    // send
    // send_resume
    // send_space
    // receive
    // receive_resumable
    // receive_with_header
    // receive_once
    // receive_with_cmdprops
    // exists
    // rollback
    // rollback_to
    // sync

// TODO Find a better way to find it via zfs lib
string zfsVersion()
{
	import std.process: executeShell;
	import std.string: splitLines, startsWith, strip, join;
	import std.algorithm: filter;
	import std.format:format;

	auto result = executeShell("modinfo zfs");
	enforce(result.status == 0, result.output);
	auto lines = result.output.splitLines.filter!(line => line.startsWith("version:"));
	return lines.front.strip;
}


@SILdoc(`Check if a dataset (a filesystem, or a volume, or a snapshot) with the given name exists.
Params:
	string path: the dataset name to check

Returns:
	true if the dataset exists, false otherwise

Note:
	datasetExists cannot be used to check for existence of bookmarks.
`)
// Exists examine whether the given path to a snapshot exists. Wrapper to the
// lzc_exists.
bool datasetExists(string path)
{
	return lzc_exists(path.toCString) !=0;
}

@SILdoc(`Create snapshots.  All snapshots must be in the same pool.  Optionally snapshot properties can be set on all snapshots.  Currently  only user properties (prefixed with "user:") are supported.  Either all snapshots are successfully created or none are created if an exception is raised.
Params:
    snapshotNames: a list of names of snapshots to be created.
    string[string] properties: ZFS dataset property name-value pairs (empty by default).

Errors:
	SnapshotFailure: if one or more snapshots could not be created.

warning:
	The underlying implementation reports an individual, per-snapshot error only for SnapshotExists condition and *sometimes* for NameTooLong.
	In all other cases a single error is reported without connection to any specific snapshot name(s).  This has the following implications:
        * if multiple error conditions are encountered only one of them is reported
        * unless only one snapshot is requested then it is impossible to tell how many snapshots are problematic and what they are
        * only if there are no other error conditions :exc:.SnapshotExists is reported for all affected snapshots
        * :exc:.NameTooLong can behave either in the same way as :exc:.SnapshotExists or as all other exceptions.  The former is the case where the full snapshot name exceeds the maximum allowed length but the short snapshot name (after '@') is within the limit.  The latter is the case when the short name alone exceeds the maximum allowed length.
`)
void snapshot(string[] snapshotNames, string[string] properties = (string[string]).init)
{
	import std.format:format;
	import std.string: join;
	auto snapshots = getList(snapshotNames);
	scope(exit)
		nvlistFree(snapshots);

	auto props = getProperties(properties);
	scope(exit)
		nvlistFree(props);

	nvlist_t* errList;
	auto result = lzc_snapshot(snapshots, props, &errList);
	if  (result != 0)
	{
		auto ret2 = processErrorList(errList);
		enforce(ret2.length ==0, format!" failed libzfs_core snapshot: %s, %s"(snapshotNames,ret2.join(",")));
	}
}

@SILdoc(`Destroy snapshots.  They must all be in the same pool.  Snapshots that do not exist will be silently ignored.

If defer is not set, and a snapshot has user holds or clones, the destroy operation will fail and none of the snapshots will be destroyed.  If defer is set, and a snapshot has user holds or clones, it will be marked for deferred destruction, and will be destroyed when the last hold or clone is removed/destroyed.  The operation succeeds if all snapshots were destroyed (or marked for later destruction if defer is set) or didnt exist to begin with.

Params:
	string[] snapshotNames: a list of names of snapshots to be destroyed.
    bool defer: whether to mark busy snapshots for deferred destruction rather than immediately failing.

Errors:
    SnapshotDestructionFailure: if one or more snapshots could not be created.

note:
    SnapshotDestructionFailure is a compound exception that provides at least one detailed error object in SnapshotDestructionFailure.errors list.  Typical error is SnapshotIsCloned if defer is False.  The snapshot names are validated quite loosely and invalid names are typically ignored as nonexisiting snapshots.  A snapshot name referring to a filesystem that doesnt exist is ignored.  However, non-existent pool name causes PoolNotFound.
`)
void destroySnapshots(string[] snapshotNames, bool deferDelete)
{
	import std.format:format;
	import std.string:join;
	auto snapshots = getList(snapshotNames);
	scope(exit) nvlistFree(snapshots);
	nvlist_t* errList;
	boolean_t cdeferDelete = (deferDelete) ? 1 : 0;
	auto result =  lzc_destroy_snaps(snapshots, cdeferDelete, &errList);
	if  (result != 0)
	{
		auto ret2 = processErrorList(errList);
		enforce(ret2.length ==0, format!"failed libzfs_core snapshot: %s, %s"(snapshotNames,ret2.join(",")));
	}
}

@SILdoc(`Destroy the ZFS dataset.
Params:
	string datasetName: the name of the dataset to destroy.

Errors:
    NameInvalid: if the dataset name is invalid.
    NameTooLong: if the dataset name is too long.
    FilesystemNotFound: if the dataset does not exist.
`)
void destroyDataset(string datasetName)
{
	import std.string:join;
	import std.format:format;
	nvlist_t* errList;
    auto result = lzc_destroy_one(datasetName.toCString,null);
	if  (result != 0)
	{
		auto ret2 = processErrorList(errList);
		enforce(ret2.length ==0, format!"failed libzfs_core snapshot: %s, %s"(datasetName,ret2.join(",")));
	}
}


@SILdoc(`Inherit properties from a parent dataset of the given ZFS dataset.
Params:
	string name: the name of the dataset.
	string prop: the name of the property to inherit.

Errors:
	NameInvalid: if the dataset name is invalid.
	NameTooLong: if the dataset name is too long.
	DatasetNotFound: if the dataset does not exist.
	PropertyInvalid: if one or more of the specified properties is invalid or has an invalid type or value.

Inheriting a property actually resets it to its default value or removes it if its a user property, so that the property could be inherited if its inheritable.  If the property is not inheritable then it would just have its default value.  This function can be used on snapshots to inherit user defined properties.
`)
void inheritProperties(string name, string property)
{
	import std.format:format;
	import std.string:join;
	nvlist_t* errList;
    auto result = lzc_inherit(name.toCString, property.toCString, null);
	if  (result != 0)
	{
		auto ret2 = processErrorList(errList);
		enforce(ret2.length ==0, format!" failed libzfs_core inheritProperties: %s, %s, %s"(name,property,ret2.join(",")));
	}
}


@SILdoc(`Set properties of the ZFS dataset.
Params:
	string name: the name of the dataset.
	string[string]: properties

Errors:
	NameInvalid: if the dataset name is invalid.
	NameTooLong: if the dataset name is too long.
	DatasetNotFound: if the dataset does not exist.
	NoSpace: if the property controls a quota and the values is too small for that quota.
	PropertyInvalid: if one or more of the specified properties is invalid or has an invalid type or value.
    This function can be used on snapshots to set user defined properties.

note:
	An attempt to set a readonly / statistic property is ignored without reporting any error.
`)
void setDatasetProperties(string name, string[string] properties)
{
	import std.format:format;
	import std.string:join;
	nvlist_t* errList;
    auto props = getProperties(properties);
	scope(exit)
		nvlistFree(props);
    auto result = lzc_set_props(name.toCString, props, null,null);
	if  (result != 0)
	{
		auto ret2 = processErrorList(errList);
		enforce(ret2.length ==0, format!" failed to set properties: %s, %s, %s"(name,properties,ret2.join(",")));
	}
}

struct PipePair
{
	int read;
	int write;
}

@SILdoc(`List subordinate elements of the given dataset.
This function can be used to list child datasets and snapshots of the given dataset.  The listed elements can be filtered by their type and by their depth relative to the starting dataset.  :param bytes name: the name of the dataset to be listed, could be a snapshot or a dataset.

Params:
	options: a dict of the options that control the listing behavior.

Returns:
	PipePair - a pair of file descriptors the first of which can be used to read the listing.

Errors:
	DatasetNotFound: if the dataset does not exist.

Two options are currently available:
recurse : integer or None
	specifies depth of the recursive listing. If None the depth is not limited.  Absence of this option means that only the given dataset is listed.
type : dict of bytes:None
	specifies dataset types to include into the listing.  Currently allowed keys are "filesystem", "volume", "snapshot".  Absence of this option implies all types.

The first of the returned file descriptors can be used to read the listing in a binary encounded format.  The data is a series of variable sized records each starting with a fixed size header, the header is followed by a serialized nvlist.  Each record describes a single element and contains the elements name as well as its properties.  The file descriptor must be closed after reading from it.  The second file descriptor represents a pipe end to which the kernel driver is writing information.  It should not be closed until all interesting information has been read and it must be explicitly closed afterwards.
`)
auto listImpl(string name, string[string] options)
{
	// import core.stdc.stdio;
	// import core.sys.posix.sys.stat;
	import core.sys.posix.unistd;
	import core.sys.posix.fcntl;
	import std.format:format;

	int[2] pipefd;
	enforce(pipe(pipefd) !=-1, "pipe error");
    fcntl(pipefd[0], F_SETFD, FD_CLOEXEC);
    fcntl(pipefd[1], F_SETFD, FD_CLOEXEC);
    options["fd"] = pipefd[1].to!string;
	auto copts = getProperties(options);
    auto result = lzc_list(name.toCString,copts);
    if (result == ESRCH) 
        return PipePair(-1,-1);
    //errors.lzc_list_translate_error(ret, name, options)
    return PipePair(pipefd[0],pipefd[1]);
}

@SILdoc(`A wrapper for listImpl that hides details of working with the file descriptors and provides data in an easy to consume format.
Params:
	string name: the name of the dataset to be listed, could be a snapshot, a volume or a filesystem.
    int recurse: specifies depth of the recursive listing.  If -1 the depth is not limited.
	string[] types: specifies dataset types to include into the listing.  Currently allowed keys are "filesystem", "volume", "snapshot". no types is equivalent to specifying the type of the dataset named by name.

Returns:
	string[string][] with each dictionary each describing a single listed element.
`)
auto list(string name, int recurse = -1, string[] types=[])
{
	import std.format:format;
	import std.algorithm:map;
	import std.string:join;
	import core.sys.posix.unistd;
	string[string][] ret;
    string[string] options;

    // Convert types to a dict suitable for mapping to an nvlist.
	// FIXME!
    if (types.length > 0)
        options["type"] = types.map!(type => type.to!string).join(",");
    if (recurse > -1)
		options["recurse"] = recurse.to!string;

    // Note that other_fd is used by the kernel side to write the data, so we have to keep that descriptor open until
    // we are done.  Also, we have to explicitly close the descriptor as the  kernel doesnt do that.

	auto pipes = listImpl(name,options);
	if (pipes.read == -1)
		return ret;

	scope(exit)
	{
		close(pipes.write);
		close(pipes.read);
	}
	while(true)
	{
		auto recordBytes = read(pipes.read, _PIPE_RECORD_SIZE);
		if (recordBytes.length == 0)
			break;
		auto record= cast(_PIPE_RECORD_FORMAT)(recordBytes);
		if (record.err == ESRCH)
			break;
		// errors.lzc_list_translate_error(record.err, name, options)
		if (record.size == 0)
			break;
		auto dataBytes = read(pipes.read, record.size);
		auto entry = processNvlist!(string[string])(dataBytes,record.size);
		ret ~= entry.dup;
	}
	return ret;
}

@SILdoc(`Get properties of the ZFS dataset.
Params:
	string name: the name of the dataset

Errors:
	DatasetNotFound: if the dataset does not exist.
	NameInvalid: if the dataset name is invalid.
	NameTooLong: if the dataset name is too long.

Returns:
	string[string] mapping the property names to their values.

note:
The value of clones property is a list of clone names as strings.

warning:
	The returned dictionary does not contain entries for properties with default values.  One exception is the mountpoint property for which the default value is derived from the dataset name.
`)
string[string] getProperties(string name)
{
	import std.format:format;
	import std.string: startsWith;
    auto result = next(list(name, 0,[]));
    bool isSnapshot = result["dmu_objset_stats"]["dds_is_snapshot"];
    result = result["properties"];

    // In most cases the source of the property is uninteresting and the value alone is
	// sufficient.  One exception is the 'mountpoint' property the final value of which
	// is not the same as the inherited value.
    auto mountpoint = result.get("mountpoint","");
	string mountpoint_src;
	string mountpoint_val;
	if (mountpoint.length > 0)
	{
        mountpoint_src = mountpoint["source"];
        mountpoint_val = mountpoint["value"];

        // 'source' is the name of the dataset that has 'mountpoint' set to a non-default value
		// and from which the current dataset inherits the property.  'source' can be the current
		// dataset if its 'mountpoint' is explicitly set.
        // 'source' can also be a special value like '$recvd', that case is equivalent to the property being set on the current dataset. Note that a normal mountpoint value should start with '/' unlike the special values "none" and "legacy".

        if (mountpoint_val.startsWith("/") && !mountpoint_src.startsWith("$"))
		{
            mountpoint_val = mountpoint_val ~ name[mountpoint_src.length..$];
		}
	}
    else if (!isSnapshot)
	{
        mountpoint_val = '/' ~ name;
	}
    else
	{
        mountpoint_val = "";
	}
    string[string] ret; // FIXME result = {k: v['value'] for k, v in result.iteritems()}
    if ("clones" in ret)
        ret["clones"] = ret["clones"].keys;
    if (mountpoint_val.length > 0)
        ret["mountpoint"] = mountpoint_val;
    return ret;
}

@SILdoc(`List the children of the ZFS dataset.
Params:
    string name: the name of the dataset

Returns:
    string[]: the names of the children.

Errors:
    NameInvalid: if the dataset name is invalid.
    NameTooLong: if the dataset name is too long.
    DatasetNotFound: if the dataset does not exist.

warning:
	If the dataset does not exist, then the returned iterator would produce no results and no error is reported.  That case is indistinguishable from the dataset having no children.  An attempt to list children of a snapshot is silently ignored as well.
`)

string[] listChildren(string name)
{
	import std.format:format;
	string[] ret;
    //foreach(entry;list(name,1,[DatasetType.filesystem, DatasetType.volume]))
    foreach(entry;list(name,1,["filesystem", "volume"]))
	{
        auto child = entry["name"];
        if (child != name)
		{
            ret ~= child;
		}
	}
	return ret;
}


@SILdoc(`List the snapshots of the ZFS dataset.
Params:
	string datasetName: the name of the dataset

Returns:
	string[] the names of the snapshots

Errors:
    NameInvalid: if the dataset name is invalid.
    NameTooLong: if the dataset name is too long.
    DatasetNotFound: if the dataset does not exist.

warning:
	If the dataset does not exist, then the returned iterator would produce no results and no error is reported.  That case is indistinguishable from the dataset having no snapshots.  An attempt to list snapshots of a snapshot is silently ignored as well.
`)
string[] listSnapshots(string datasetName)
{
	import std.format:format;
	string[] ret;
    foreach(entry; list(datasetName, 1, ["snapshot"]))
	{
        auto snap = entry["name"];
        if (snap != datasetName)
		{
            ret ~= snap;
		}
	}
    return ret;
}

// NvlistAlloc is a wrapper for nvlist_alloc.
nvlist_t* nvlistAlloc(uint nvflag, int kmflag)
{
	nvlist_t* cnvlist;
	auto result = nvlist_alloc(&cnvlist, nvflag, kmflag);
	enforce(result ==0, "failed to allocate nvlist");
	return cnvlist;
}

// NvlistFree is a wrapper for nvlist_free.
void nvlistFree(nvlist_t* cnvlist)
{
	nvlist_free(cnvlist);
}

@SILdoc(` Destroy the ZFS dataset.
Params:
	string name: the name of the dataset to destroy

Errors:
    NameInvalid: if the dataset name is invalid.
    NameTooLong: if the dataset name is too long.
    FilesystemNotFound: if the dataset does not exist.
`)
ZfsResult destroy(string name)
{
	import std.format:format;
	auto result = lzc_destroy(name.toCString);
	return zfsResult(result==0, ZfsError.noent, format!"failed to destroy %s: %s"(name,result));
}


// Process the error list returned from the libzfs_core functions in the types
// of nvlist_t. The keys are the snapshot names that failed and the values are
// the errno corresponding to each failed snapshot.
string[] processErrorList(nvlist_t* errList)
{
	import std.format:format;
	string[] ret;
	if (isNvlistEmpty(errList)) {
		return ret;
	}

	scope(exit)
		nvlistFree(errList);
	int errNum;
	nvpair_t* elem = nextNvPair(errList);
	while(elem !is null)
	{
		auto s = nvpair_name(elem).fromCString.idup;
		nvpair_value_int32(elem, &errNum);
		ret ~= format!"Failed Snapshot '%s':%s"(s,errNum);
		elem = nvlist_next_nvpair(errList, elem);
	}
	return ret;
}

ulong[string] processNvlist(T)(nvlist_t* list)
if (is(T==ulong[string]))
{
	ulong[string] ret;
	nvpair_t* elem;
	nvpair_value_nvlist(elem,&list);
	nvpair_t* listElem = nextNvPair(list);
	ulong[string] dictEntry;
	while(listElem !is null)
	{
		auto listElemKey = nvpair_name(listElem).fromCString.idup;
		ulong val;
		nvpair_value_uint64(listElem,&val);
		ret[listElemKey] = val;
	}
	return ret;
}


ulong[string][string] processNvlist(T)(nvlist_t* bookmarks)
if (is(T==ulong[string][string]))
{
	ulong[string][string] ret;
	if (isNvlistEmpty(bookmarks))
	{
		return ret;
	}
	scope(exit)
		nvlistFree(bookmarks);
	nvpair_t* elem = nextNvPair(bookmarks);
	while(elem !is null)
	{
		auto s = nvpair_name(elem).fromCString.idup;
		nvlist_t* list;
		nvpair_value_nvlist(elem,&list);
		nvpair_t listElem = nextNvPair(list);
		ret[s] = processNvlist!(ulong[string])(listElem).dup;
	}
	return ret;
}

			


nvpair_t* nextNvPair(nvlist_t* list, nvpair_t* elemArg = null)
{
	nvpair_t* elem;
	if (elemArg !is null)
		elem = elemArg;
	elem = nvlist_next_nvpair(list, elem);
	return elem;
}

nvlist_t* getProperties(string[string] properties)
{
    nvlist_t* ret = nvlistAlloc(NV_UNIQUE_NAME,0);
    foreach(entry;properties.byKeyValue)
    {
        enforce(nvlist_add_string(ret,entry.key.toCString,entry.value.toCString)==0, "allocating properties");
    }
    return ret;
}

nvlist_t* getList(string[] values)
{
    nvlist_t* ret = nvlistAlloc(NV_UNIQUE_NAME,0);
    foreach(value;values)
    {
        nvlistAddBoolean(ret,value);
    }
    return ret;
}


// NvlistAddBoolean is a wrapper for nvlist_add_boolean.
void nvlistAddBoolean(nvlist_t* nvlist, string name)
{
	import std.format:format;
	auto errnoResult = nvlist_add_boolean(nvlist, name.toCString);
	enforce(errnoResult ==0, format!"Failed to add boolean: %s"(errnoResult));
}
// NvlistEmpty is a wrapper for nvlist_empty.
bool isNvlistEmpty(nvlist_t* cnvlist)
{
	return (nvlist_empty(cnvlist) !=0);
}

string[string] asDict(nvlist_t* list)
{
	string[string] ret;
	auto pair = nextNvPair(list,null);
	while( pair !is null)
	{
		auto name = nvpair_name(pair).fromCString.idup;
		char* val;
		auto result = nvpair_value_string(pair, &val);
		enforce(result ==0);
		ret[name] = val.fromCString.idup;
		pair = nvlist_next_nvpair(list,pair);
	}
	return ret;
}

	

//void create(string filesystem, DataSetType dataSetType, Property[] properties, ubyte[] wkeyData)
// lzc_create(filesystem.toCString, cast(lzc_dataset_type) dataSetType, properties.asPtr,wkeyData.ptr,wkeyData.length.to!uint_t);
@SILdoc(`Create a ZFS filesystem
Params:
	string name					-	name of the dataset to be created
	string[string] properties	-	a dictionary od ZFS dataset property name-value pairs
	ubyte[] encryptionKey		-	dataset encryption key data

Errors:
	FilesystemExists			-	if a dataset with the given name already exists
	ParentNotFound				-	if a parent dataset of the requested dataset does not exist
	PropertyInvalid				-	if one or more of specified properties does not exist or has an invalid type or value
	NameInvalid					-	if the name is not a valid dataset name
	NameTooLong					-	if the name is too long
	WrongParent					-	if the parent dataset of the requested dataset is not a filesystem eg zvol
`)

void createFileSystem(string path, string[string] properties = (string[string]).init, string encryptionKey=null)
{
	import std.format:format;
	auto props = getProperties(properties);
	enforce(props !is null, "alloc failure for props for "~path );
	scope(exit)
		nvlistFree(props);

	auto cpath = path.toCString;
	auto result = lzc_create(cpath, LZC_DATSET_TYPE_ZFS, props,cast(ubyte*)encryptionKey.ptr,encryptionKey.length.to!uint);
	enforce(result ==0, format!"Failed libzfs_core create: %s"(result));
}



ZfsResult validate(string zpool)
{
	import std.file:exists;
	import std.process:executeShell;
	import std.exception;
	import std.format:format;
	auto result = executeShell("modprobe zfs");
	enforce(result.status==0, "ZFS Kernel module not found");
	return zfsResult(exists(zpool), ZfsError.noent, format!"pool %s not found"(zpool));
}

struct ZfsResult
{
	ZfsError status;
	string message;
}

auto zfsResult(bool success, ZfsError status, string message)
{
	return success ? ZfsResult(ZfsError.success,"") : ZfsResult(status,message);
}


@("libzfs_core")
unittest
{
	import std.stdio;
	//auto result = validate("tank3");
	// writeln(result);
	auto testSnap = ["tank3/shared/kaleidic@snapfoo"];
	snapshot(testSnap);
	writeln("success creating");
	destroySnapshots(testSnap,false);
	writeln("success destroying");
	create("tank3/shared/foo",DatasetType.zfs);
	writeln("success creating tank3/shared/foo");
	destroy("tank3/shared/foo");
	writeln("success destroying tank3/shared/foo");
}

