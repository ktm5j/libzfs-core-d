/+
	work towards Dlang wrapper for libzfs-core
+/


#include <stdint.h>
#include <libzfs_core.h>


struct SILdoc {string value; }


// int lzc_ioctl(zfs_ioc_t ioc, const char *name, nvlist_t *source, nvlist_t **resultp)

struct Zfs
{
	void this()
	{
		enforce(libzfs_core_init() == 0, "Error initialising ZFS");
	}
	~this()
	{
		libzfs_core_fini();
	}	
}


void create(string filesystem, DataSetType dataSetType, Property[] properties, ubyte[] wkeyData)
{
	auto result = lzc_create(filesystem.toCString, cast(lzc_dataset_type) dataSetType, properties.asPtr,wkeyData.ptr,wkeyData.length.to!uint_t);
	enforce(result==0,"something went wrong");
}

void clone(string filesystem, string origin, Property[] properties)
{
	auto result = lzc_clone(filesystem.toCString,origin.toCString,properties.ptr);
	enforce(result==0,"something went wrong");
}

void promote(string filesystem, string snapName)
{
	auto result = lzc_promote(filesystem.toCString.snapName.ptr,snapName.length);
	enforce(result==0,"something went wrong");
}

void remap(string filesystem)
{
	auto result = lzc_remap(filesystem.toCString);
	enforce(result==0,"something went wrong");
}

auto createSnapshot(Snap[] snapshots, Property[] properties)
{
	auto result = lzc_snapshot(snapshots.asPtr,properties.asPtr,errList);
	enforce(result==0,"something went wrong");
}


auto destroySnapshots(Snap[] snapshots, bool defer)
{
	nvlist_t* errlist;
	auto result = lzc_destroy_snaps(snapshots.asPtr,defer,&errList);
	enforce(result==0,"something went wrong");
}

auto snapRangeSpace(string firstSnap, string lastSnap)
{
	auto result = lzc_snaprange_space(firstSnap.toCString, lastSnap.toCstring);
	enforce(result>=0, "zfs error");
	return result;
}

bool datasetExists(string datasetName)
{
	return (lzc_exists(datasetName.toCString) !=0);
}


auto poolSync(string poolName, NVL[] nvl)
{
	// outnvl is unusued
	nvlist_t* outnvl;
	auto result = lzc_sync(poolName.toCString,innvl,&outnvl);
}


void holdSnapshot(Snap[] holdSnapshots, int cleanUpFD)
{
	int lzc_hold(nvlist_t *holds, int cleanup_fd, nvlist_t **errlist)
}


void unholdSnapshot(Snap[] holdSnapshots, int cleanupFD)
{
	int lzc_hold(nvlist_t *holds, int cleanup_fd, nvlist_t **errlist)
}

auto getHeldSnapshots(string snapName)
{
	int lzc_get_holds(const char *snapname, nvlist_t **holdsp)
}

enum SendFlag
{
	largeBlock = LZC_SEND_FLAG_LARGE_BLOCK,
	embedData = LZC_SEND_FLAG_EMBED_DATA,
	compress = LZC_SEND_FLAG_COMPRESS,
	raw = LZC_SEND_FLAG_RAW
}

@SILdoc(`
Generate a zfs send stream for the specified snapshot and write it to
the specified file descriptor.
 
"snapname" is the full name of the snapshot to send (e.g. "pool/fs@snap")

If "from" is NULL, a full (non-incremental) stream will be sent.
If "from" is non-NULL, it must be the full name of a snapshot or
bookmark to send an incremental from (e.g. "pool/fs@earlier_snap" or
"pool/fs#earlier_bmark").  If non-NULL, the specified snapshot or
bookmark must represent an earlier point in the history of "snapname").
It can be an earlier snapshot in the same filesystem or zvol as "snapname",
or it can be the origin of "snapname"'s filesystem, or an earlier
snapshot in the origin, etc.

"fd" is the file descriptor to write the send stream to.

If "flags" contains LZC_SEND_FLAG_LARGE_BLOCK, the stream is permitted
to contain DRR_WRITE records with drr_length > 128K, and DRR_OBJECT
records with drr_blksz > 128K.

If "flags" contains LZC_SEND_FLAG_EMBED_DATA, the stream is permitted
to contain DRR_WRITE_EMBEDDED records with drr_etype==BP_EMBEDDED_TYPE_DATA,
which the receiving system must support (as indicated by support
for the "embedded_data" feature).

If "flags" contains LZC_SEND_FLAG_COMPRESS, the stream is generated by using
compressed WRITE records for blocks which are compressed on disk and in
memory.  If the lz4_compress feature is active on the sending system, then
the receiving system must have that feature enabled as well.

If "flags" contains LZC_SEND_FLAG_RAW, the stream is generated, for encrypted
datasets, by sending data exactly as it exists on disk.  This allows backups
to be taken even if encryption keys are not currently loaded.
`)

auto sendSnapshot(string snapshotName, string fromSnapshot, int fileDescriptor, SendFlag[] flags)
{
	auto lzcFlags = flags.fold!((a,b) => a| b,lzc_send_flags.init);
	auto result = lzc_send(snapshotName.toCString, fromSnapshot.toCString,fileDescriptor,lzcFlags);
	enforce(result == 0, "zfs error");
}

auto sendResume(string snapshotName, string fromSnapshot, int fileDescriptor, SendFlag[] flags, ulong resumeObj, ulong resumeOff)
{
	auto lzcFlags = flags.fold!((a,b) => a| b,lzc_send_flags.init);
	auto result = lzc_send_resume(snapshotName.toCString, fromSnapshot.toCstring, fileDescriptor, lzcFlags, resumeObj, resumeOff);
	enforce(result == 0, "zfs error");
}

@SILdoc(`
"from" can be NULL, a snapshot, or a bookmark.

If from is NULL, a full (non-incremental) stream will be estimated.  This
is calculated very efficiently.

If from is a snapshot, lzc_send_space uses the deadlists attached to
each snapshot to efficiently estimate the stream size.

If from is a bookmark, the indirect blocks in the destination snapshot
are traversed, looking for blocks with a birth time since the creation TXG of
the snapshot this bookmark was created from.  This will result in
significantly more I/O and be less efficient than a send space estimation on
an equivalent snapshot.
`)
auto sendSpace(string snapshotName, string from, SendFlag[] flags)
{
	auto lzcFlags = flags.fold!((a,b) => a| b,lzc_send_flags.init);
	ulong retSpace;
	auto result = lzc_send_space(snapshotName.toCString, from.toCstring, lzcFlags,&retSpace);
	enforce(result == 0, "zfs error");
}


auto recvRead(int fileDescriptor, ubyte[] buf)
{
	auto result = recv_read(fileDescriptor,cast(void*)buf.ptr,buf.length.to!int);
	enforce(result == 0, format!"zfs error: %s"(result));
}

*
 * Linux adds ZFS_IOC_RECV_NEW for resumable and raw streams and preserves the
 * legacy ZFS_IOC_RECV user/kernel interface.  The new interface supports all
 * stream options but is currently only used for resumable streams.  This way
 * updated user space utilities will interoperate with older kernel modules.
 *
 * Non-Linux OpenZFS platforms have opted to modify the legacy interface.
 */
int recv_impl(const char *snapname, nvlist_t *recvdprops, nvlist_t *localprops, uint8_t *wkeydata, uint_t wkeylen, const char *origin, boolean_t force, boolean_t resumable, boolean_t raw, int input_fd, const dmu_replay_record_t *begin_record, int cleanup_fd, uint64_t *read_bytes, uint64_t *errflags, uint64_t *action_handle, nvlist_t **errors)

@SILdoc(`zfs receive:
The simplest receive case: receive from the specified fd, creating the
specified snapshot.  Apply the specified properties as "received" properties
(which can be overridden by locally-set properties).  If the stream is a
clone, its origin snapshot must be specified by 'origin'.  The 'force'
flag will cause the target filesystem to be rolled back or destroyed if
necessary to receive.

Return 0 on success or an errno on failure.

Note: this interface does not work on dedup'd streams (those with DMU_BACKUP_FEATURE_DEDUP).
`)
auto zfsReceive(string snapName, Property[] properties, string origin, bool force, bool raw, int fileDescriptor)
{
	auto result = lzc_receive(snapName.toCString, properties.asPtr,origin.toCString, force? 1:0, raw?1:0, fileDescriptor);
}

*
 * Like lzc_receive, but if the receive fails due to premature stream
 * termination, the intermediate state will be preserved on disk.  In this
 * case, ECKSUM will be returned.  The receive may subsequently be resumed
 * with a resuming send stream generated by lzc_send_resume().
 */
int
lzc_receive_resumable(const char *snapname, nvlist_t *props, const char *origin,
    boolean_t force, boolean_t raw, int fd)
/*
 * Like lzc_receive, but allows the caller to read the begin record and then to
 * pass it in.  That could be useful if the caller wants to derive, for example,
 * the snapname or the origin parameters based on the information contained in
 * the begin record.
 * The begin record must be in its original form as read from the stream,
 * in other words, it should not be byteswapped.
 *
 * The 'resumable' parameter allows to obtain the same behavior as with
 * lzc_receive_resumable.
 */
int
lzc_receive_with_header(const char *snapname, nvlist_t *props,
    const char *origin, boolean_t force, boolean_t resumable, boolean_t raw,
    int fd, const dmu_replay_record_t *begin_record)

*
 * Like lzc_receive, but allows the caller to pass all supported arguments
 * and retrieve all values returned.  The only additional input parameter
 * is 'cleanup_fd' which is used to set a cleanup-on-exit file descriptor.
 *
 * The following parameters all provide return values.  Several may be set
 * in the failure case and will contain additional information.
 *
 * The 'read_bytes' value will be set to the total number of bytes read.
 *
 * The 'errflags' value will contain zprop_errflags_t flags which are
 * used to describe any failures.
 *
 * The 'action_handle' is used to pass the handle for this guid/ds mapping.
 * It should be set to zero on first call and will contain an updated handle
 * on success, it should be passed in subsequent calls.
 *
 * The 'errors' nvlist contains an entry for each unapplied received
 * property.  Callers are responsible for freeing this nvlist.
 */
int lzc_receive_one(const char *snapname, nvlist_t *props,
    const char *origin, boolean_t force, boolean_t resumable, boolean_t raw,
    int input_fd, const dmu_replay_record_t *begin_record, int cleanup_fd,
    uint64_t *read_bytes, uint64_t *errflags, uint64_t *action_handle,
    nvlist_t **errors)\

@SILdoc(`Like lzc_receive_one, but allows the caller to pass an additional 'cmdprops' argument.

The 'cmdprops' nvlist contains both override ('zfs receive -o') and
exclude ('zfs receive -x') properties. Callers are responsible for freeing
this nvlist
`)
auto zfsReceiveWithCommandProperties(string snapName, Property[] properties, Property[] commandProperties, ubyte[] keyData, string origin, bool force, bool resumable, bool raw, int inputFileDescriptor, DmuReplyRecord* beginRecord, int cleanupFileDescriptor)
{
	ulong readBytes;
	ulong errFlags;
	ulong actionHandle;
	nvlist_t* errors;

	auto result = lzc_receive_with_cmdprops(snapName.toCString, properties.asPtr, commandProperties.asPtr, keyData.ptr, keyData.length.to!uint, origin.toCString, force ? 1 :0, resumable ? 1 :0, raw ? 1 : 0, inputFileDescriptor, beginRecord, cleanupFileDescriptor, &readBytes, &errFlags, &actionHandle, &errors);
	enforce(result == 0, format!"zfs error %s"(result));
}


@SILdoc(`Roll back this filesystem or volume to its most recent snapshot
If snapnamebuf is not NULL, it will be filled in with the name
of the most recent snapshot.
Note that the latest snapshot may change if a new one is concurrently
created or the current one is destroyed.  lzc_rollback_to can be used
to roll back to a specific latest snapshot.

Return 0 on success or an errno on failure.
`)
auto rollback(string fsname, string snapName)
{
	auto result = lzc_rollback(fsname.toCString, snapName.ptr, snapName.length.to!int);
	enforce(result ==0, "zfs error");
}

@SILdoc(`Roll back this filesystem or volume to the specified snapshot, if possible`)
void rollbackTo(string fsName, string snapName)
{
	auto result = lzc_rollback_to(fsName.toCString, snapName.toCString);
	enforce(result == 0, format!"zfs error: %s"(result));
}

@SILdoc(`Creates bookmarks.

The bookmarks nvlist maps from name of the bookmark (e.g. "pool/fs#bmark") to
the name of the snapshot (e.g. "pool/fs@snap").  All the bookmarks and
snapshots must be in the same pool.

The returned results nvlist will have an entry for each bookmark that failed.
The value will be the (int32) error code.

The return value will be 0 if all bookmarks were created, otherwise it will
be the errno of a (undetermined) bookmarks that failed.
`)
auto createBookmarks(Bookmark[] bookmarks)
{
	nvlist_t* errlist;
	auto result = lzc_bookmark(bookmarks.asPtr, &errlist);
	enforce(result == 0, format!" zfs error: %s"(result));
}


@SILdoc(`
Retrieve bookmarks.

Retrieve the list of bookmarks for the given file system. The props
parameter is an nvlist of property names (with no values) that will be
returned for each bookmark.

The following are valid properties on bookmarks, all of which are numbers
(represented as uint64 in the nvlist)

"guid" - globally unique identifier of the snapshot it refers to
"createtxg" - txg when the snapshot it refers to was created
"creation" - timestamp when the snapshot it refers to was created

The format of the returned nvlist as follows:
 <short name of bookmark> -> {
    <name of property> -> {
         "value" -> uint64
    }
  }
`)
auto getBookmarks(string fsName, Property[] properties)
{
	nvlist_t* bmarks;
	auto result = lzc_get_bookmarks(fsName.toStringz, properties.asPtr,&bmarks);
	enforce(result == 0, "ZFS error");
	return NvList(bmarks);
}

@SILdoc(`Destroys bookmarks

The keys in the bmarks nvlist are the bookmarks to be destroyed.
They must all be in the same pool.  Bookmarks are specified as
<fs>#<bmark>.

Bookmarks that do not exist will be silently ignored.

The return value will be 0 if all bookmarks that existed were destroyed.

Otherwise the return value will be the errno of a (undetermined) bookmark
that failed, no bookmarks will be destroyed, and the errlist will have an
entry for each bookmarks that failed.  The value in the errlist will be
the (int32) error code.
`)
auto destroyBookmarks(Bookmark[] bookmarks)
{
	nvlist_t* errlist;
	auto result = lzc_destroy_bookmarks(bookmarks.asPtr,&errlist);
	enforce(result == 0, "zfs error");
	return 0;
}


@SILdoc(`Executes a channel program

If this function returns 0 the channel program was successfully loaded and
ran without failing. Note that individual commands the channel program ran
may have failed and the channel program is responsible for reporting such
errors through outnvl if they are important.

This method may also return:

 EINVAL   The program contains syntax errors, or an invalid memory or time
          limit was given. No part of the channel program was executed.
          If caused by syntax errors, 'outnvl' contains information about the
          errors.

 ECHRNG   The program was executed, but encountered a runtime error, such as
          calling a function with incorrect arguments, invoking the error()
          function directly, failing an assert() command, etc. Some portion
          of the channel program may have executed and committed changes.
          Information about the failure can be found in 'outnvl'.

 ENOMEM   The program fully executed, but the output buffer was not large
          enough to store the returned value. No output is returned through
          'outnvl'.

 ENOSPC   The program was terminated because it exceeded its memory usage
          limit. Some portion of the channel program may have executed and
          committed changes to disk. No output is returned through 'outnvl'.

 ETIME    The program was terminated because it exceeded its Lua instruction
          limit. Some portion of the channel program may have executed and
          committed changes to disk. No output is returned through 'outnvl'.
`)
void executeChannelProgram(string pool, string program, ulong instrLimit, ulong memLimit, NvList args)
{
	nvlist_t** outnvl;
	auto result = lzc_channel_program(pool.toCString, program.toCString, instrLimit, memLimit, args.asPtr, &outnvl);
	enforce(result == 0, format!"zfs error: %s"(result));
}


@SILdoc(`Creates a checkpoint for the specified pool.

If this function returns 0 the pool was successfully checkpointed.

This method may also return:

 ZFS_ERR_CHECKPOINT_EXISTS
	The pool already has a checkpoint. A pools can only have one
    checkpoint at most, at any given time.

 ZFS_ERR_DISCARDING_CHECKPOINT
 	ZFS is in the middle of discarding a checkpoint for this pool.
 	The pool can be checkpointed again once the discard is done.

 ZFS_DEVRM_IN_PROGRESS
 	A vdev is currently being removed. The pool cannot be
 	checkpointed until the device removal is done.

 ZFS_VDEV_TOO_BIG
 	One or more top-level vdevs exceed the maximum vdev size
 	supported for this feature.
`)
auto createCheckpoint(string pool)
{
	auto result = lzc_pool_checkpoint(pool.toCString);
	enforce(result == 0, format!"zfs error: %s"(result));
}

@SILdoc(`Discard the checkpoint from the specified pool`)
void discardCheckpoint(string pool)
{
	auto result = lzc_pool_checkpoint_discard(pool.toCString);
	enforce(result != ZFS_ERR_NO_CHECKPOINT, "The pool does not have a checkpoint.");
	enforce(result != ZFS_ERR_DISCARDING_CHECKPOINT, "ZFS is already in the middle of discarding the checkpoint.");
}

@SILdoc(`
Executes a read-only channel program.

A read-only channel program works programmatically the same way as a
normal channel program executed with lzc_channel_program(). The only
difference is it runs exclusively in open-context and therefore can
return faster. The downside to that, is that the program cannot change
on-disk state by calling functions from the zfs.sync submodule.

The return values of this function (and their meaning) are exactly the
same as the ones described in lzc_channel_program().
`)
auto executeChannelProgramNoSync(string pool, string program, ulong timeout, ulong memLimit, NvList[] args)
{
	nvlist_t* outnvl;
	auto result = lzc_channel_program_nosync(pool.toCString, program.toCString, timeout, memLimit, args.asPtr, &ret);
	enforce(result == 0, "zfs error");
	return NvList(outnvl);
}

/*
 * Performs key management functions
 *
 * crypto_cmd should be a value from dcp_cmd_t. If the command specifies to
 * load or change a wrapping key, the key should be specified in the
 * hidden_args nvlist so that it is not logged.
 */
int lzc_load_key(const char *fsname, boolean_t noop, uint8_t *wkeydata, uint_t wkeylen)

auto loadKey(string fsName, bool noOp, ubyte wkeyData)
{
	auto result = lzc_load_key(fsName.toCString, noOp, wkeyData.ptr, wkeyData.length);
}

auto unloadKey(string fsName)
{
int lzc_unload_key(const char *fsname)
{
	return (lzc_ioctl(ZFS_IOC_UNLOAD_KEY, fsname, NULL, NULL));
}

int
lzc_change_key(const char *fsname, uint64_t crypt_cmd, nvlist_t *props,
    uint8_t *wkeydata, uint_t wkeylen)

int
lzc_reopen(const char *pool_name, boolean_t scrub_restart)
{



enum DataSetType
{
	zfs = lzc_dataset_type.LZC_DATASET_TYPE_ZFS,
	zvol = lzc_dataset_type.LZC_DATASET_TYPE_ZVOL,
}

void snapshot(DataSet dataSet, Snap[] snaps, Properties[] properties)
{
	auto result = lzc_snapshot(snaps.asPtr, properties.asPtr, null);
	enforce(result ==0, "Error creating snapshot");
}
	
// clone
    // promote
    // destroy_snaps
    // bookmark
    // get_bookmarks
    // destroy_bookmarks
    // snaprange_space
    // hold
    // release
    // get_holds
    // send
    // send_resume
    // send_space
    // receive
    // receive_resumable
    // receive_with_header
    // receive_once
    // receive_with_cmdprops
    // exists
    // rollback
    // rollback_to
    // sync


// TODO Find a better way to find it via zfs lib
string version()
{
	if o, err := exec.Command("modinfo", "zfs").Output(); err == nil {
		// Dumps a lot of info here, just split it at new line
		res := strings.Split(string(o), "\n")

		for _, r := range res {
			// ZFS version information starts with 'version:' so look for that
			if strings.HasPrefix(r, "version:") {
				// Get the version and return
				return strings.TrimSpace(strings.TrimLeft(r, "version:"))
			}
		}
	}

	// Didn't find the version info
	return ""
}


// Clone from a snapshot. Wrapper for the libzfs_clone.
// TODO: the properties arg are ignored for now, which should be reintroduced.
func clone(dest string, src string, autoMount datalayer.MountType) error {
	props, err := nvlistAlloc(C.NV_UNIQUE_NAME, 0)
	if err != nil {
		return err
	}

	defer nvlistFree(props)
	cdest, csrc := C.CString(dest), C.CString(src)
	defer C.free(unsafe.Pointer(cdest))
	defer C.free(unsafe.Pointer(csrc))
	ret := C.lzc_clone(cdest, csrc, props)
	if ret != 0 {
		return fmt.Errorf("Failed libzfs_core clone: %d", ret)
	}

	return nil
}

// Exists examine whether the given path to a snapshot exists. Wrapper to the
// lzc_exists.
func exists(path string) bool {
	cpath := C.CString(path)
	defer C.free(unsafe.Pointer(cpath))

	// The return type from lzc_exists is boolean_t. Although
	// conceptually, it is equivalent of the golang bool type, the type is
	// not considered to be matching. Therefore, we need to do the clumpsy
	// way of comparing it to the B_TURE value to convert the returned
	// value to golang bool type.
	return (C.lzc_exists(cpath) == C.B_TRUE)
}

// Snapshot takes snapshots. Wrapper for lzc_snapshot.
func snapshot(snapshotNames []string) error {
	snapshots, err := nvlistAlloc(C.NV_UNIQUE_NAME, 0)
	if err != nil {
		return err
	}

	defer nvlistFree(snapshots)
	for _, ssName := range snapshotNames {
		err := nvlistAddBoolean(snapshots, ssName)
		if err != nil {
			return err
		}
	}

	// TODO: For now, we let the properties to be empty.
	props, err := nvlistAlloc(C.NV_UNIQUE_NAME, 0)
	if err != nil {
		return err
	}

	defer nvlistFree(props)
	var errList *C.nvlist_t
	ret := C.lzc_snapshot(snapshots, props, &errList)
	if ret != 0 {
		ret2 := processErrorList(errList)
		if ret2 != nil {
			return ret2
		}
		return fmt.Errorf("Failed libzfs_core snapshot: %d", ret)
	}
	return nil
}

// DestroySnapshot destroies the snapshots passed in. Wrapper for lzc_destroy_snaps
void destroySnapshot(string[] snapshotNames, bool deferDelete)
{
	snapshots, err := nvlistAlloc(C.NV_UNIQUE_NAME, 0)
	if err != nil {
		return err
	}

	defer nvlistFree(snapshots)
	for _, ssName := range snapshotNames {
		err := nvlistAddBoolean(snapshots, ssName)
		if err != nil {
			return err
		}
	}

	var errList *C.nvlist_t
	var cdeferDelete C.boolean_t
	// This is not exactly clean, but since the input needs to be a
	// C.boolean_t, there is no easy translation between golang bool
	// type into the C type.
	if deferDelete {
		cdeferDelete = C.B_TRUE
	} else {
		cdeferDelete = C.B_FALSE
	}

	ret := C.lzc_destroy_snaps(snapshots, cdeferDelete, &errList)
	if ret != 0 {
		ret2 := processErrorList(errList)
		if ret2 != nil {
			return ret2
		}
		return fmt.Errorf("Failed libzfs_core snapshot: %d", ret)
	}
	return nil
}

// Destroy is the wrapper for lzc_destroy_one
void destroy(string name)
{
	cname := C.CString(name)
	defer C.free(unsafe.Pointer(cname))
	// The only allowed property is the defer, but we leave it empty for
	// now
	props, err := nvlistAlloc(C.NV_UNIQUE_NAME, 0)
	if err != nil {
		return err
	}

	defer nvlistFree(props)
	ret := C.lzc_destroy_one(cname, props)
	if ret != 0 {
		return fmt.Errorf("Failed to destroy '%s': %d", name, ret)
	}

	return nil
}

// List is the wrapper for lzc_list_iter
func list(zpool string) ([]string, error) {
	// TODO: Not Implemented
	return nil, fmt.Errorf("Not Implemented")
}

// Process the error list returned from the libzfs_core functions in the types
// of nvlist_t. The keys are the snapshot names that failed and the values are
// the errno corresponding to each failed snapshot.
void processErrorList(errList *C.nvlist_t)
{
	if nvlistEmpty(errList) {
		return nil
	}

	scope(exit)
		nvlistFree(errList)
	var elem *C.nvpair_t
	var errno C.int32_t
	for {
		elem = C.nvlist_next_nvpair(errList, elem)
		if elem == nil {
			break
		}

		s := C.nvpair_name(elem)
		C.nvpair_value_int32(elem, &errno)
		log.Printf("Failed Snapshot '%s':%d\n", C.GoString(s), int(errno))
	}

	return fmt.Errorf("ZFS core Lib returned error")
}

// NvlistAlloc is a wrapper for nvlist_alloc.
func nvlistAlloc(nvflag int, kmflag int) (*C.nvlist_t, error) {
	var cnvlist *C.nvlist_t
	ret := C.nvlist_alloc(&cnvlist, C.uint_t(nvflag), C.int(kmflag))
	if ret != 0 {
		return nil, fmt.Errorf("Failed to allocation nvlist")
	}

	return cnvlist, nil
}

// NvlistFree is a wrapper for nvlist_free.
func nvlistFree(cnvlist *C.nvlist_t) {
	C.nvlist_free(cnvlist)
}

// NvlistAddBoolean is a wrapper for nvlist_add_boolean.
func nvlistAddBoolean(cnvlist *C.nvlist_t, name string) error {
	cname := C.CString(name)
	defer C.free(unsafe.Pointer(cname))
	errno := C.nvlist_add_boolean(cnvlist, cname)
	if errno != 0 {
		return fmt.Errorf("Failed to add boolean: %d", errno)
	}

	return nil
}

// NvlistEmpty is a wrapper for nvlist_empty.
func nvlistEmpty(cnvlist *C.nvlist_t) bool {
	return (C.nvlist_empty(cnvlist) == C.B_TRUE)
}

void createFileSystem(string path)
{
	props, err := nvlistAlloc(C.NV_UNIQUE_NAME, 0)
	if err != nil {
		return err
	}
	defer nvlistFree(props)

	cpath := C.CString(path)
	defer C.free(unsafe.Pointer(cpath))

	ret := C.lzc_create(cpath, C.LZC_DATSET_TYPE_ZFS, props)
	if ret != 0 {
		return fmt.Errorf("Failed libzfs_core create: %d", ret)
	}
	return nil
}

void destroyFileSystem(string path)
{
	throw new Exception("Not implemented");
}

auto getSnapshotSpace(datalayer.SnapshotSpace)
{
	throw new Exception("Not implemented");
}

auto getFSAndDescendantsSpace(fs string) (datalayer.DiskSpace, error) {
	// TODO: complete this code
	return datalayer.DiskSpace{}, fmt.Errorf("Not Implemented")
}

void validate(string zpool)
{
	auto result = executeShell("modprobe zfs");
	enforce(result.status==0, "ZFS Kernel module not found");

	if !exists(filepath.Join([]string{"", zpool})) {
		return &ErrZpoolNotFound{Zpool: zpool}
	}
}
